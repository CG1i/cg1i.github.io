<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Pages-Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的二进制【2】</title>
    <url>/2022/09/03/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E7%BA%A7%E5%88%B6%E3%80%902%E3%80%91/</url>
    <content><![CDATA[<h1 id="2-在射击游戏中防止玩家作弊"><a href="#2-在射击游戏中防止玩家作弊" class="headerlink" title="2.在射击游戏中防止玩家作弊"></a>2.在射击游戏中防止玩家作弊</h1><h3 id="2-1-解读内存转储"><a href="#2-1-解读内存转储" class="headerlink" title="2.1 解读内存转储"></a>2.1 解读内存转储</h3><p>修改二进制数据（修改内存）需要使用进程内存编辑工具。（书中用的兔耳旋风是日文界面，中文系统下会乱码）</p>
<p>内存转储：将内存数据保存成文件。</p>
<blockquote>
<p>程序在运行时，内存的数据会不断的实时变化，如果要保存某个时间点的状态（快照），就需要内存转储了。</p>
</blockquote>
<p>生成内存转储过程：</p>
<span id="more"></span>

<ul>
<li>打开任务管理器</li>
<li>右键点击目标进程名称</li>
<li>选择“创建转储文件”  </li>
</ul>
<p><img src="/images/2022/202209032137.png" alt="内存转储"></p>
<p>这样系统就会生成一个扩展名为<code>.DMP</code>的文件。在Windows XP以及更低版本中自带一个叫Dr.Watson的内存转储工具，当进程异常终止时会将内存和简单日志保存到文件中。<br>操作系统会按照可执行文件中的内容将程序加载到内存中，但内存的数据和可执行文件中的数据并不完全一致。  </p>
<p>转储文件可以使用++WinDbg++分析。</p>
<p>Java程序特点：</p>
<ul>
<li>在编译时，源代码会被编译成字节码（一种抽象的中间语言）</li>
<li>为各种环境分别安全能够解释和和执行字节码的虚拟机</li>
</ul>
<blockquote>
<p>对于java程序进行分析，相当于对Java字节码进行分析。一些工具能够将字节码还原成源代码，这些工具称为反编译器（decompiler）。</p>
</blockquote>
<h3 id="2-2如何防止软件被别人分析"><a href="#2-2如何防止软件被别人分析" class="headerlink" title="2.2如何防止软件被别人分析"></a>2.2如何防止软件被别人分析</h3><p><strong>IsDebuggerPresent</strong>是最初级的一种反调试技术，能够检测是否 挂在了调试器的API函数，通过返回值是否为0可以判断调试器的挂载状态。<br>类似的还有一些其他的API函数，如CheckRemoteDebuggerPresent。</p>
<p>关于其他类型的检测技术搜索关键词“anti-debug popf”和“anti-debug int2d”。</p>
<p><strong>代码混淆</strong>让代码变得难以看懂，以防止代码被分析。一些混淆技术能够提高反编译的难度，让文件在反编译时出错。</p>
<p>抗篡改性（tamper resistance）指系统内部结构抵御分析的能力。</p>
<p><strong>打包器</strong>（packer）将可执行文件进行压缩，压缩后的文件依然可以直接运行。例如开源工具UPX。也有一些打包器的目的不是压缩，而是反调试，例如ASPack。</p>
<p><strong>解包器</strong>（unpacker）将用打包器压缩的可执行文件解压缩的工具。</p>
<p>手动解包：用调试器和反汇编器跟踪可执行文件解压缩的逻辑，并将位于内存中的解压缩后的可执行数据导出到文件的操作。</p>
<p>软件断点：本质是调试器将断点位置的指令改写成了0xCC（int3h）。处理器遇到0xCC 指令，会通过操作系统将异常报告给调试器，因此，只要在指定位置写入0xCC，就可以在任意时间和位置中断程序运行。</p>
<p>硬件断点：通过直接写入寄存器（DR寄存器）来实现中断程序允许并向调试器发出报告。还可以实现一些复杂的中断，例如“当向指定地址写入数据时中断”“当从指定地址读取数据时中断”等等。</p>
<p>硬件断点设置数量有限，处理器只设计了4个硬件断点，软件断点的设置没有限制。在软件分析的过程中，打包器在向内存写入解包等候的可执行数据时，会覆盖掉其中的软件断点，因此需要使用硬件断点。</p>
<blockquote>
<p>无论什么软件，其本质都是处理器可以解释并指定的机器语言指令，因此“即便采取了难度再高的对策，只要能够读出组成软件的所有机器语言指令，就一定能找到破解的方法”。</p>
</blockquote>
<p>.NET程序：与Java类似，在编译时会生成一种MSIL（Microsoft Intermediate Language）的中间语言，并在允许时通过CLR（Common Language Runtime）转换成处理器能够解释的机器语言。因此，对.NET的分析就相当于对MSIL的分析，反编译器可使用<a href="https://www.red-gate.com/products/dotnet-development/reflector/">.NET Reflector</a>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八月底和做题</title>
    <url>/2022/08/31/%E5%85%AB%E6%9C%88%E5%BA%95%E5%92%8C%E5%81%9A%E9%A2%98/</url>
    <content><![CDATA[<h3 id="八月底和做题"><a href="#八月底和做题" class="headerlink" title="八月底和做题"></a>八月底和做题</h3><p><em>第一篇日志，得给自己说明一下，此刻的想法是在这个类型下：记录一下近期发生的事情，可能就是流水账。同时以后的hexo配置更新也会记在这里面</em></p>
<span id="more"></span>

<p>&emsp;&emsp;我先想想这个八月我干了什么事情…emmm…想到什么就写什么吧。<br>&emsp;&emsp;首先有个网鼎的赛，一如既往的签了个到，然后搜了脚本改了改，碰出那个简单的哈希。这些题我也好久没有认真练过了，菜！脚本也不会写，好久以前就想学一下的，一直拖到现在，得抓紧提上日程了，顺带再…也别顺带了，先整完手头上的东西，再去想那没尾的事。杂项web没有想法，嗯？周五的上午半天就这么过去了，下午还要去工作，不做了！！点外卖！！<br>&emsp;&emsp;能完整看完一本书对我来讲可太不容易了，我的书大多数都是看一半就扔一边了，然后又开新坑。这此可把这本二进制书看完了，算是结束一个大阶段。后面把书上的摘抄整理，分5章传这上面。<br>&emsp;&emsp;本来想用GitHub建图床，用来给这里贴图，详细想想可能还是用云存储会好些吧，后面再比较一下用谁家的云存储。然后是发现手里排的事情有点多了，而且没有完结的，就会越堆越多。先加紧把手头的整完，下半年还有考试，准备准备也是要时间的，按月来算安排手里也就没有多少了。<br>&emsp;&emsp;嗯？(っ °Д °;)っ突然就穷起来了呢。</p>
<hr>
<blockquote>
<p>hexo结构上没有改什么设置，就是开了总浏览量，换了一个网站图标，太小了，看得模糊。还改了文篇分类和标签，后面看看要不要对分类和标签页面进行设置美化一下，404页面也要改一下了。</p>
</blockquote>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>生活日常</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的二进制【3】</title>
    <url>/2022/09/03/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%903%E3%80%91/</url>
    <content><![CDATA[<h1 id="3-利用软件的漏洞进行攻击"><a href="#3-利用软件的漏洞进行攻击" class="headerlink" title="3 利用软件的漏洞进行攻击"></a>3 利用软件的漏洞进行攻击</h1><h3 id="3-1-利用缓存区溢出来执行任意代码"><a href="#3-1-利用缓存区溢出来执行任意代码" class="headerlink" title="3.1 利用缓存区溢出来执行任意代码"></a>3.1 利用缓存区溢出来执行任意代码</h3><p>缓冲区溢出（buffer overflow）在软件的安全漏洞中，是最有名的漏洞之一。输出的数据超出来程序规定的内存范围，数据溢出导致程序发生异常。</p>
<p>setuid机制让用户使用程序的所有者权限来运行程序。<br>/bin/sh是UNIX类系统的外壳程序，如果用root权限启动它，就相当于可以用root权限对系统进行任何操作。  </p>
<span id="more"></span>

<p>栈是一种内存的使用方式，也是普通的内存空间。在信息工程中，栈叫做LIFO(Last In,First out),即后进先出，而像队列这种先进先出则叫FIFO（FIrst In，First Out）。</p>
<p><strong>gdb</strong>工具是在UNIX类操作系统中常用的调试器，是一个命令行工具。</p>
<h3 id="3-2-防御攻击的技术"><a href="#3-2-防御攻击的技术" class="headerlink" title="3.2 防御攻击的技术"></a>3.2 防御攻击的技术</h3><p><strong>ALSR</strong>(Adress Space Layout Randomization)地址空间分布随机化，是一种对栈、模块、动态分布的内存空间等的地址进行随机化配置的机制。<br>属于操作系统的功能。<br>通过/proc/sys/kernel/randomize_va_space (Linux) 配置。</p>
<ul>
<li>0：禁用</li>
<li>1：除堆以外随机化</li>
<li>2：全部随机化（默认）</li>
</ul>
<p><strong>Exec-Shield</strong> 是一种通过“限制内存空间的读写和执行权限”来防御攻击的机制。</p>
<p><strong>StackGuard</strong> 是一种在编译时在各函数入口和出口插入用于检测栈数据完整性的机器语言代码的方法。属于编译器的安全机制。<br>StackGuard机制所保护的是 ebp和 ret_addr，是一种针对典型栈缓冲区溢出攻击的防御手段。<br>gcc默认开启StackGuard，编译时加上 -fno-stack-protector 参数可以关闭StackGuard。</p>
<h3 id="3-3-绕开安全机制的技术"><a href="#3-3-绕开安全机制的技术" class="headerlink" title="3.3 绕开安全机制的技术"></a>3.3 绕开安全机制的技术</h3><p><strong>Return-into-libc</strong> 是一种破解 Exec-Shield 的方法，思路是“即便无法执行任意代码（shellcode），最终只要能够运行任意程序，也可以夺取系统权限”。<br>基本原理是通过调整参数和栈的配置，是的程序能够跳转到 libc.so 中的 system 函数以及 exec 类函数，借此来运行 /bin/sh 等程序。<br>使用 <code>ldd</code> 命令查看程序运行时所加载的库。</p>
<p><strong>ROP</strong>（Return-Oriented-Programming,面向返回编程）利用未随机化的模块内部的汇编代码进行攻击。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的二进制【1】</title>
    <url>/2022/08/31/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%901%E3%80%91/</url>
    <content><![CDATA[<blockquote>
<p><em>主要是想细致的学习一下二进制，正好手里有这本书就先拿出来看了，后面再看别的视频或书啥的吧，学这个还是得多动手。书里的示例操作我都会做一遍，流程写的很细所以这里就不再记了，可能有些章节重点都是操作，那就没啥记的了。有些知识的拓展习惯记在note上了，以后有空再另整理吧。</em></p>
</blockquote>
<h1 id="1通过逆向工程学习如何读懂二进制代码"><a href="#1通过逆向工程学习如何读懂二进制代码" class="headerlink" title="1通过逆向工程学习如何读懂二进制代码"></a>1通过逆向工程学习如何读懂二进制代码</h1><h3 id="1-1-体验一下软件分析"><a href="#1-1-体验一下软件分析" class="headerlink" title="1.1 体验一下软件分析"></a>1.1 体验一下软件分析</h3><p>分析要点：</p>
<span id="more"></span>

<ul>
<li>文件的创建、修改和删除</li>
<li>注册表项目的创建、修改和删除</li>
<li>网络通信</li>
</ul>
<p>工具：</p>
<ul>
<li><a href="http://www.winhex.com/winhex/">WinHex</a> (二进制编辑器，书中用的Stirling是日文软件，换了)</li>
<li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">Process Monitor</a>（文件和注册表监控）</li>
<li><a href="https://www.wireshark.org/">Wireshark</a>（网络监控）</li>
</ul>
<p><a href="https://github.com/shyujikou/binarybook">书中涉及到的示例文件和源代码项目地址</a> （部分文件会被杀软报毒）</p>
<blockquote>
<p>对软件进行分析并搞清楚其行为的工作就是“逆向工程”。逆向工程是指一般意义上的软件分析，其对象不仅限于恶意软件，因此也不一定和计算机安全有关。</p>
</blockquote>
<h3 id="1-2-尝试静态分析"><a href="#1-2-尝试静态分析" class="headerlink" title="1.2 尝试静态分析"></a>1.2 尝试静态分析</h3><p>软件分析从方法上分为两种：</p>
<ul>
<li>静态分析：在不运行目标程序的情况下进行分析</li>
<li>动态分析：在允许目标程序的同时进行分析</li>
</ul>
<p>静态分析主要包括：</p>
<ul>
<li>阅读反汇编代码</li>
<li>提取可执行文件中的字符串，分析使用了哪些单词</li>
</ul>
<p>使用二进制编辑器查看可执行文件的内容也算作一种静态分析。</p>
<p>反汇编工具：<a href="https://hex-rays.com/download-center/">IDA Free</a>(免费版)<br>（免费版的性能差不多够用了，需要记一些常用的功能快捷键。）</p>
<h3 id="1-3尝试动态分析"><a href="#1-3尝试动态分析" class="headerlink" title="1.3尝试动态分析"></a>1.3尝试动态分析</h3><p>动态分析是在目标程序运行的同时跟踪其行为的方法，主要用调试器来跟踪程序逻辑，其他动态分析方法：</p>
<ul>
<li>获取文件和注册表访问日志</li>
<li>抓取网络包</li>
</ul>
<p><strong>Process Monitor</strong>监控工具分析目标程序，通过设置过滤规则，可以输出文件和注册表的访问日志。</p>
<p><a href="https://www.ollydbg.de/"><strong>OllyDbg</strong></a>调试器可以进一步跟踪程序逻辑。</p>
<p>调试器是一种帮助发现程序问题和bug的软件，一般来说至少应具备以下功能：</p>
<ul>
<li>断点</li>
<li>单步跳入、跳出</li>
<li>查看寄存器和内存数据</li>
</ul>
<blockquote>
<p>断点是能够让程序在任意位置中断、恢复运行的功能，可以帮助寻找导致问题的程序逻辑。<br>断点能够在任意文字中断和恢复运行，而每执行一条指令都中断一次就叫做单步跳入或跳出。通过单步运行功能，可以以一条指令或者一行代码或单位逐个运行程序中的逻辑，仔细确认内存和变量的状态。跳入和跳出的区别如下：</p>
<blockquote>
<p>跳入：调用函数时进入函数内部<br>跳出：调用函数时不进入函数内部，而是将函数调用作为一条指令来执行</p>
</blockquote>
</blockquote>
<blockquote>
<p>查看寄存器和内存数据功能可以在程序中断运行的状态下确认寄存器、内存和变量的状态。</p>
</blockquote>
<p>OllyDbg可以洞察程序的详细逻辑。</p>
<p><img src="/images/2022/202208312125.png" alt="OllyDbg 界面"></p>
<p>地址跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反汇编窗口内按 Ctrl + G</span><br><span class="line">右键菜单中点击 Go To -&gt; Expression</span><br></pre></td></tr></table></figure>
<p>设置断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选中地址所在行，按F2</span><br><span class="line">右键菜单选择 Breakpoint -&gt; Toggle</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按F9</span><br><span class="line">菜单栏中点击 Debug -&gt; Run</span><br></pre></td></tr></table></figure>
<p>其他：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F7 表示单步跳入</span><br><span class="line">F8 表示单步跳出</span><br><span class="line">Ctrl + A 表示重新分析程序代码</span><br><span class="line">Ctrl + F9 表示运行至Return处</span><br><span class="line">Alt + F9 表示运行至用户代码处</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Windows环境下的几个调试器：</p>
<ul>
<li>OllyDbg</li>
<li><a href="http://www.immunityinc.com/products/debugger/">Immunityh Debugger</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/">WinDbg</a></li>
</ul>
<p>Immunity Debugger 也和 OllyDbg 一样具备图形用<br>户界面，Immunity Debugger 和 Python 的亲和性较高，WinDbg能够对系统内核领域的程序进行调试,在分析像 Rootkit 这样在 Windows内核中运行的恶意程序时也需要它。</p>
<h3 id="1-4-学习最基础的汇编指令"><a href="#1-4-学习最基础的汇编指令" class="headerlink" title="1.4 学习最基础的汇编指令"></a>1.4 学习最基础的汇编指令</h3><p>书中列举的常见汇编指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>示例</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MOV</td>
<td>MOV EAX,ECX</td>
<td>EAX = ECX</td>
<td>将ECX的值存入EAX</td>
</tr>
<tr>
<td>ADD</td>
<td>ADD EAX,ECX</td>
<td>EAX += ECX</td>
<td>将EAX的值加上ECX的值</td>
</tr>
<tr>
<td>SUB</td>
<td>SUB EAX,ECX</td>
<td>EAX -= ECX</td>
<td>将EAX的值减去ECX的值</td>
</tr>
<tr>
<td>INC</td>
<td>INC EAX</td>
<td>EAX ++</td>
<td>将EAX的值加1</td>
</tr>
<tr>
<td>DEC</td>
<td>DEC EAX</td>
<td>EAX -</td>
<td>将EAX的值减1</td>
</tr>
<tr>
<td>LEA</td>
<td>LEA EAX,[ECX+4]</td>
<td>EAX = ECX+4</td>
<td>将ECX+4的值存入EAX</td>
</tr>
<tr>
<td>CMP</td>
<td>CMP EAX,ECX</td>
<td>if(EAX==ECX)<br>&emsp;ZF=1<br>else<br>&emsp;ZF=0</td>
<td>对两个值进行比较并根据结果设置标至<br>若EAX与ECX相同，则ZF=1<br>若EAX与ECX不同，则ZF=0</td>
</tr>
<tr>
<td>TEST</td>
<td>TEST EAX,EAX</td>
<td>if(EAX==0)<br>&emsp;ZF=1<br>else<br>&emsp;ZF=0</td>
<td>将值与0进行比较并根据结果设置标志<br>若EAX位0，则ZF=1<br>若EAX不为0，则ZF=0</td>
</tr>
<tr>
<td>JE(JZ)</td>
<td>JE 04001000</td>
<td>if(ZF==1)<br>&emsp;GOTO 04001000</td>
<td>若ZF为1，则跳转到04001000</td>
</tr>
<tr>
<td>JNE(JNZ)</td>
<td>JNE 04001000</td>
<td>if(ZF==0)<br>&emsp;GOTO 04001000</td>
<td>若ZF为0，则跳转到04001000</td>
</tr>
<tr>
<td>JMP</td>
<td>JMP 04001000</td>
<td>GOTO 04001000</td>
<td>无条件跳转到04001000</td>
</tr>
<tr>
<td>CALL</td>
<td>CALL lstrcmp W</td>
<td></td>
<td>调用lstrcmp W</td>
</tr>
<tr>
<td>PUSH</td>
<td>PUSH 00000001</td>
<td></td>
<td>将00000001入栈</td>
</tr>
<tr>
<td>POP</td>
<td>POP EAX</td>
<td></td>
<td>出栈并将获取的值存入EAX</td>
</tr>
</tbody></table>
<p>CMP、TEST、JE以及JNE指令可用于在汇编语言中实现条件分支。<br>一般的编程语言中，都是通过if、switch等保留字来表现条件分支的。而在汇编语言中，则是通过控制标志的CMP、TEST指令，以及根据标志完成分支的跳转类指令来实现。</p>
<p>汇编语言中，参数是按照从后往前的顺序入栈的，实际上这方面的规则会根据CPU和编译器的不同而存在一些差异，这里只要记住“++参数是通过栈来传递++”。</p>
<h3 id="1-5-通过汇编指令洞察程序行为"><a href="#1-5-通过汇编指令洞察程序行为" class="headerlink" title="1.5 通过汇编指令洞察程序行为"></a>1.5 通过汇编指令洞察程序行为</h3><p><em>对OllyDbg和IDA的使用去网上搜索吧，教程很多。</em></p>
<p>逆向工程逻辑<strong>理解原则</strong>：<br>重要的部分花时间仔细理解，其余部分大概知道怎么回事就好。</p>
<p>书中使用的Windows环境下汇编器是 <a href="https://www.nasm.us/">NASM</a>，连接器是 ALINK。</p>
<p>测试使用的关于Windows API的信息，在MSDN（Microsoft Developer Network）搜索。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的二进制【4】</title>
    <url>/2022/09/07/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%904%E3%80%91/</url>
    <content><![CDATA[<h1 id="4-自由控制程序运行方式的编程技巧"><a href="#4-自由控制程序运行方式的编程技巧" class="headerlink" title="4 自由控制程序运行方式的编程技巧"></a>4 自由控制程序运行方式的编程技巧</h1><h3 id="4-1-通过自制调试器来理解其原理"><a href="#4-1-通过自制调试器来理解其原理" class="headerlink" title="4.1 通过自制调试器来理解其原理"></a>4.1 通过自制调试器来理解其原理</h3><p>WIN32API-<strong>CreateProces</strong>函数启动调试目标，调试目标进程也叫调试对象或者被调试程序（debuggee）。如果设置来 DEBUG_PROCESS 或 DEBUG_ONLY_THIS_PROCESS 标志，则启动的进程（调试对象）中所产生的异常都会被调试器捕捉到。</p>
<ul>
<li>DEBUG_PROCESS标志：调试对象所产生的子进程，以及子进程都作为调试对象</li>
<li>DEBUG_ONLY_THIS_PROCESS：只将通过CreateProcess启动的那个进程作为调试对象</li>
</ul>
<span id="more"></span>

<blockquote>
<p>CreatProcess函数的第1个参数或者第2个参数可以用于传递目标程序。通过CREATE_SUSPENDED标志可以让进程在启动后进入挂起状态。当设置这一标志时，CreateProcess函数调用完成后，新程序中的所欲线程都会暂停。尽管程序没有在运行，但程序的可执行文件已经被载入内存，这时可以在运行之前对调试对象的数据进行改写。</p>
</blockquote>
<p><strong>udis86</strong>是一个开源的反汇编器。<a href="https://github.com/vmt/udis86">项目链接</a></p>
<blockquote>
<p>在Windows中，即使我们的程序不是作为调试器挂载在目标进程上，只要能够获取目标进程的句柄，就可以随意读写该进程的内存空间。当然，当前用户如果没有相应的权限，调用 OpenProcess 会失败，但只要能够通过其他方法获取进程句柄，也可以自由读写该进程的内存空间。</p>
</blockquote>
<h3 id="4-2-在其他进程中注入代码"><a href="#4-2-在其他进程中注入代码" class="headerlink" title="4.2 在其他进程中注入代码"></a>4.2 在其他进程中注入代码</h3><p>在其他进程中运行任意代码的手法，统称为代码注入（code injection）。在使用DLL的情况下，一般叫做“DLL注入”，但“在其他进程中运行自己的代码”这一点是共通的。</p>
<p>关于DLL注入，有一篇著名的文章叫“<a href="https://www.codeproject.com/Articles/4610/Three-Ways-to-Inject-Your-Code-into-Another-Proces">Three Ways to Inject Your Code into Another Process</a>”<br>里面列举了三种方法。</p>
<blockquote>
<p>在 Windows中，只要拥有足够的权限，就可以访问其他进程的内存空间，因此我们基本上可以自由地向其他进程注入代码，而且即使程序不是调试器，也可以比较容易的骗过其他进程。</p>
</blockquote>
<h3 id="4-3任意替换程序逻辑：API钩子"><a href="#4-3任意替换程序逻辑：API钩子" class="headerlink" title="4.3任意替换程序逻辑：API钩子"></a>4.3任意替换程序逻辑：API钩子</h3><p>在程序中插入额外的逻辑称为“钩子”，而其中对API插入额外逻辑称为“API钩子”。</p>
<p>API钩子可分为两类：</p>
<ul>
<li>改写目标函数开头几个字节</li>
<li>改写IAT（Import Address Table，导入地址表）</li>
</ul>
<p>IAT型钩子在 <em>Advanced Windows</em> 书中有详细描述。</p>
<p>使用Detours的API钩子库可以实现一个简单的API钩子，而不需要从零开始写大量的代码。<br>根据环境和对象文件的不同，API钩子也有各种各样的实现方法，Detours是用一种非常简单的方法来实现，详细文献–<a href="https://www.microsoft.com/en-us/research/publication/detours-binary-interception-of-win32-functions/">Detours:Binary Interception of Win32 Functions</a>。<br>Detours的源代码是公开的。  </p>
<blockquote>
<p>钩子的原理是将函数开头的几个字节替换成jmp指令，强制跳转到另一个函数。API钩子基本上只适用于运行在用户领域的DLL所导出的函数，但我们也可以通过劫持非公开的API等方式，对运行在内核领域（Ring0）的驱动程序挂载钩子。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>测试01</title>
    <url>/2022/08/20/%E6%B5%8B%E8%AF%9501/</url>
    <content><![CDATA[<h3 id="测试记录"><a href="#测试记录" class="headerlink" title="测试记录"></a>测试记录</h3><pre><code>这里测试一次文字，原生语法不支持缩进
</code></pre>
<p><strong>真不习惯</strong></p>
<p>页面搭建进度：整体结构完成，完成较少部分的配置，也遇到一些冲突问题，与想达到的效果不同，后续将继续美化配置整改。<br><strong>这里将记录部分的笔记，一些日常见闻或者说说日志。</strong></p>
<span id="more"></span>

<hr>
<p>8/21</p>
<p>next版本是8.12，配置了背景、圆角、标签等，因为版本问题，部分网上的配置方法部分不适用，下次需要注意。<br>标签和分类等页面还没整，后续弄好。</p>
<hr>
<p>8/22</p>
<p>解决了标签、分类页，后续将配置美化一下。尝试使用<!--more-->截断首页的文，先试试效果。<br>    在翻译文件中解决了强力驱动的翻译问题，不翻译就用英文更顺眼一些。<br>    字体等细节后面慢慢整了。后续开始推一些笔记试试水。不过大部分都是word格式的，是个问题，待解决。后面看看别的框架，个人还是word格式 ╯︿╰</p>
<hr>
<p>8/23</p>
<blockquote>
<p>熟悉了一些markdown的语法，得用HTML代码解决一些格式问题，后面整理一下，防止忘了。貌似word格式难解决，摸了。  </p>
</blockquote>
<hr>
<p>8/25</p>
<blockquote>
<p>解决了部分字体问题，只是修改了size-base，整的看别的字也有变小的。后面再细修。可以传一些东西了。</p>
</blockquote>
]]></content>
      <categories>
        <category>Pages-Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的二进制【5】</title>
    <url>/2022/09/09/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%905%E3%80%91/</url>
    <content><![CDATA[<h1 id="5-使用工具探索更广阔的的世界"><a href="#5-使用工具探索更广阔的的世界" class="headerlink" title="5 使用工具探索更广阔的的世界"></a>5 使用工具探索更广阔的的世界</h1><blockquote>
<p><em>第五章多是工具的使用，也接着第三章讲了ROP。考虑书出版有些久，工具迭代出新，可能有更合适的，这就不细记了，对于常用的工具应该单独出篇。</em></p>
</blockquote>
<h3 id="5-1-使用Metasploit-Framework验证和调查漏洞"><a href="#5-1-使用Metasploit-Framework验证和调查漏洞" class="headerlink" title="5.1 使用Metasploit Framework验证和调查漏洞"></a>5.1 使用Metasploit Framework验证和调查漏洞</h3><p><strong>Metasploit Framework</strong>是一个用于生成和运行攻击代码的框架，通常也简称为Metasploit。这个攻击有Windows版和Linux版，通常用来验证和调查软件的漏洞。</p>
<ul>
<li><a href="https://www.rapid7.com/products/metasploit/">Metasploit</a></li>
</ul>
<span id="more"></span>

<p>各个安全漏洞的信息都在一个叫做<a href="https://www.cve.org/">CVE</a>（Common Vulnerabilities and Exposures）的数据库中进行统一管理。<br>其中每一条漏洞都被编号，格式如CVE-YYYY-NNNN（其中YYYY为年份，NNNN为序号）。根据漏洞编号，可以从CVE的网站上搜索到以下信息：</p>
<ul>
<li>对漏洞的描述</li>
<li>漏洞所影响的软件</li>
<li>漏洞所影响的版本</li>
</ul>
<p>只要知道来发生漏洞的软件、操作系统以及它们的版本，就可以搭建一个相同的环境，对漏洞进程验证和调查。</p>
<ul>
<li><a href="https://www.rapid7.com/db/?type=metasploit">Metasploit Auxiliary Module &amp; Exploit Database</a></li>
</ul>
<p>使用Metasploit，可以根据环境和目的自动生成shellcode，生成shellcode需要使用Metasploit附带的msfpayload工具。处于学习的目的，一开始还是自己编写shellcode比较好，等理解了其原理之后再使用工具提高效率。</p>
<p><strong>ROP</strong>（面向返回编程）就是将一些以返回（ret指令）结束的代码片段拼接起来，从而实现真正期望的逻辑。在ROP中，要运行的代码被配置在栈中，通过巧妙地调整进行跳转并运行这些代码。简单来说，就是用ret代替jmp进行跳转。</p>
<h3 id="5-2-用EMET观察反ROP的机制"><a href="#5-2-用EMET观察反ROP的机制" class="headerlink" title="5.2 用EMET观察反ROP的机制"></a>5.2 用EMET观察反ROP的机制</h3><p><strong>EMET</strong>全称为Enhanced Mitigation Experience Toolkit（增强减灾体验工具），是微软发布的一款免费漏洞缓解工具。3.0级之前版本中，其主要特长是“强化现有的安全机制”，从3.5版本开始则增加了一些新的实验性的探测功能。</p>
<p>微软2012年举办的计算机安全方案打算“蓝帽奖”（BlueHat prize）中获奖的方案全部都与ROP相关，而且这些方案都非常实用。</p>
<ul>
<li><a href="http://www.cs.columbia.edu/~vpappas/papers/kbouncer.pdf">kBouncer: Efficient and Transparent ROP Mitigation</a></li>
<li><a href="https://github.com/ivanfratric/ropguard">ROPGuard-runtime prevention of return-oriented programming attacks</a></li>
<li>BlueHat Prize Submission:/ROP</li>
</ul>
<p>安全技术研究的目标在于以下两点：</p>
<ul>
<li>保护应用程序不受各种漏洞的影响</li>
<li>设计出不会产生漏洞的架构</li>
</ul>
<h3 id="5-3-用REMnux分析恶意软件"><a href="#5-3-用REMnux分析恶意软件" class="headerlink" title="5.3 用REMnux分析恶意软件"></a>5.3 用REMnux分析恶意软件</h3><p><strong>REMnux</strong>是一个用于分析恶意软件的操作系统，给予Ubuntu开发，主要用于在VMware等虚拟环境下运行。</p>
<ul>
<li><a href="https://remnux.org/">REMnux</a></li>
</ul>
<p>REMnux基于特征库来工作，因此无法应对新的恶意软件。</p>
<h3 id="5-4-用ClamAV检测恶意软件和漏洞攻击"><a href="#5-4-用ClamAV检测恶意软件和漏洞攻击" class="headerlink" title="5.4 用ClamAV检测恶意软件和漏洞攻击"></a>5.4 用ClamAV检测恶意软件和漏洞攻击</h3><p>使用clamscan命令调用GPL协议的反病毒软件<strong>ClamAV</strong>对恶意软件和漏洞攻击进行扫描。</p>
<ul>
<li><a href="http://www.clamav.net/">ClamAV</a></li>
</ul>
<p>ClamAV特征文件扩展名为<code>.cvd</code>，其中main.cvd为基本数据库，daily.cvd为每日新增的特征数据库。</p>
<p>检测恶意文件的方法主要有：</p>
<ul>
<li>使用文件整体的散列值</li>
<li>使用文件内部特定的数据序列</li>
<li>为了避免误判设置某些白名单</li>
</ul>
<p>使用pescanner命令可以根据文件的元数据检测出所使用的的打包器或者疑似恶意软件的文件。</p>
<h3 id="5-5-用Zero-Wine-Tryouts分析恶意软件"><a href="#5-5-用Zero-Wine-Tryouts分析恶意软件" class="headerlink" title="5.5 用Zero Wine Tryouts分析恶意软件"></a>5.5 用Zero Wine Tryouts分析恶意软件</h3><p><strong>Zero Wine Tryouts</strong>是一个恶意软件分析工具，它的原理和REMnux不同。它是个开源的自动分析工具，通过动态分析来得出结果。</p>
<p>Zero Wine Tryouts以系统镜像的形式发布，可直接运行在开源虚拟机QEMU上。其内部是一个基于Wine的沙箱环境。Wine是一个能够在Linux、BSD、Solaris、OS X等非Windows环境下运行Windows程序（PE文件）的运行时库。</p>
<ul>
<li><a href="https://www.winehq.org/">Wine</a></li>
</ul>
<p>Zero Wine Tryouts的分析报告包含以下这些部分：</p>
<ul>
<li><strong>Report</strong>： API函数调用日志</li>
<li><strong>File headers</strong>： 文件头以及相应的特征信息</li>
<li><strong>Signatures</strong>: 文件的特征码</li>
<li><strong>Differences</strong>： 运行前后发生变化的文件和注册表日志</li>
</ul>
<h3 id="5-6-尽量减少人工分析：启发式技术"><a href="#5-6-尽量减少人工分析：启发式技术" class="headerlink" title="5.6 尽量减少人工分析：启发式技术"></a>5.6 尽量减少人工分析：启发式技术</h3><p>启发式技术：对恶意软件的“行为检测”。</p>
<ul>
<li>“频繁访问注册表的行为，疑似恶意软件”</li>
<li>“频繁收发小的网络数据包，疑似恶意软件”</li>
</ul>
<p>启发式技术是对恶意软件的行为特征进行归类，并将符合这些特征的软件判定为恶意软件。</p>
<p><strong>Adobe Malware Classifier</strong>是Adobe公司发布的开源的恶意软件检测引擎，可以对Windows可执行文件（PE文件）进行恶意软件检测，程序本身是用Python编写。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>网页浏览优化</title>
    <url>/2022/09/16/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="网页优化"><a href="#网页优化" class="headerlink" title="网页优化"></a>网页优化</h1><p>&emsp;&emsp;起因是公司里用来查资料的云主机配置很低——只有2核4G，也就只能百度一下。但如果要再登个微信，开个word，就开不了几个网页了，万一打开的博客还加载了一堆特效，能放PPT都是好的了。 以前学的一点网页的知识全还回去了，于是就记录一下。</p>
<span id="more"></span>

<p>对于CSDN这类会开动图背景的建议：</p>
<blockquote>
<p>按 F12 打开开发者选项，在Elements元素的Styles样式里找到 <code>body&#123; background: url(xxxx) &#125;</code>项，光标移至background参数前，将自动出现的√点击取消。  </p>
</blockquote>
<p>由于是在打开网页后进行操作的，在按F12时可能就已经在卡了，所以需要慢一点，给浏览器一点.反.映.的.时.间。</p>
<p>对于一些开了动态效果的博客，考虑<strong>直接提前关闭浏览器的JavaScript</strong>，但存在网页部分功能无法使用的后果。貌似这并不会影响到背景动图。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo格式语法</title>
    <url>/2022/08/23/%E9%83%A8%E5%88%86%E6%A0%BC%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="语法技巧以及HTML代码"><a href="#语法技巧以及HTML代码" class="headerlink" title="语法技巧以及HTML代码"></a>语法技巧以及HTML代码</h3><blockquote>
<p>这里记录一些我没记住的md语法以及格式代码，基本的md语法教程都很容易搜到，后面一些用到了的语法格式我也会继续在这篇里补充更新，所有的语法效果都会在对应章节使用。</p>
</blockquote>
<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>&emsp;&emsp;markdown不能用tab缩进就很难受，搜了一下，要使用HTML代码。  </p>
<p>&emsp;&emsp;用 <code>&amp;emsp;</code> 或 <code>&amp;#8195;</code> (注意有分号)可以占两个空格，连用两个就可空四个空格，达到中文缩进的效果。</p>
<p>&emsp;&emsp;另外，<code>&amp;ensp;</code> 或 <code>&amp;#8194;</code> 可以占一个空格，连用四个也是一样的。 </p>
<p>&emsp;&emsp;不换行空格用：<code>&amp;nbsp;</code> 或 <code>&amp;#160;</code> 也是占一格。</p>
<span id="more"></span>


<h4 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h4><p>居中对齐的排布还是用HTML。（以后就直接写HTML算了）</p>
<pre><code>用 &lt;center&gt; 和 &lt;/center&gt; 就可以居中对齐
</code></pre>
<center>或者</center>  
  
<pre><code>用&lt;p align=&quot;center&quot;&gt; ... &lt;/p&gt;居中
</code></pre>
<h4 id="markdown的语法"><a href="#markdown的语法" class="headerlink" title="markdown的语法"></a>markdown的语法</h4><p><strong>代码效果</strong></p>
<p>使用反引号 ` 包含住需要展示的code，就可以出现<code>code</code>展示效果。</p>
<pre><code>使用tab制表符可以实现代码块效果。
</code></pre>
<p><strong>区块</strong></p>
<blockquote>
<p>段落开头使用右尖括号<code>&gt;</code>,再跟一个空格可以引用区块</p>
<blockquote>
<p>区块可以嵌套，多一个 <code>&gt;</code> 就多一层</p>
<blockquote>
<p>这是最后一层，使用了 <code>&gt;&gt;&gt;</code></p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Pages-Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
        <tag>md语法</tag>
      </tags>
  </entry>
</search>
